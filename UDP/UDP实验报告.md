# <center>UDP实验报告</center>
<center>计32 顾晓韬 2013011298</center>


## 完成情况

* 基础功能
	
	本次实验使用C++实现了一个S-C模式的UDP通讯协议，客户端通过键盘输入的方式读取一个字符串，以回车键结束，服务器向客户端发送urlencoding处理过的字符串，并等待下一次查询。主要精力放在协议设计上，url encoding部分参考了网络代码。

* 扩展功能

	* 分组传输
	
		客户端和服务器的接收缓冲区存在大小限制，如果传输的包过大而不加处理，可能会产生错误或丢失信息。因此，我对客户端和服务器之间传输的数据包进行了大小限制。一个超出数据包大小的字符串会被分割成多个数据包，并依次传输，从而解决缓冲区限制的问题。在程序中为了突出分组的效果，我将数据包大小设为3个字节。
		
	* 可靠性协议

		udp是不可靠协议，通讯双方发出的包不一定能顺利到达目的地。我在协议中加入了对数据包的到达检查（ack），以保证通讯数据的完整性。
	 
	* 模拟丢包
		
		通过随机数方法模拟一个20%丢包率的网络环境，使得服务器、客户端都有较大概率丢包，以此测试系统的稳定性和可靠性。
	
	* 超时重传

		对于需要确认的数据包发送行为设置了超时重传机制，防止丢包引起的阻塞卡死。
		
	
##	数据结构
为方便协议的描述，定义了一些数据结构

* Package结构

	用于描述一个数据包。在一次查询中，查询字符串可能被拆成多个数据包，这些数据包作为一个分组被依次传送和确认。
	
	| 变量名  				| 类型			| 说明 			             |
	|:------ 				|:----        |:-------------           |
	| package_num    	| int 	       | 当前数据包在整个分组中的编号 |
	| tot\_package\_num	| int	       | 整个分组的总数据包数量      |
	| timestamp 			| char\*      | 当次查询的唯一标识：时间戳  |
	| package\_type		| PackageType | 一个枚举类型，标示数据包类型  |
	
* PackageType
	
	枚举类型，用于标示数据包类型，共有8种类型。
	
	
	| 类型名  				| 说明 			             |
	|:------ 				|:-------------           |
	| REQUEST_PACKAGE   | 来自客户端的请求数据包，搭载查询字符串的片段或ACK |
	| RESPONSE_PACKAGE	| 来自服务器的请求数据包，搭载答案字符串的片段或ACK |
	| CHECK_REQUEST 		| 确认请求数据包的ACK  |
	| CHECK_RESPONSE		| 确认答案数据包的ACK  |
	| ASK_FOR_ANSWER   	| 客户端请求答案数据串的数据包 |
	| EMPTY_PACKAGE		| 空数据包，多用于     |
	| END_OF_SESSION 	| 当次查询的唯一标识：时间戳  |
	| ENOUGH_RESENT		| 一个枚举类型，标示数据包类型  |
	
* timestamp\_to\_rawstrings

	一个map结构，由服务器维护。key是timestamp字符串，value是一个string数组，存放该timestamp代表的一次请求会话的原查询字符串，每个数组元素代表原查询字符串拆分成的分组中编号与数组下标一致的子字符串。
	
	
## 通讯协议

<a>基本的通信协议流程框架如下图：</a>

![MacDown Screenshot](flow.jpg)

### 协议流程框架：
* **阶段1：客户端发送请求**
	* 服务器等待请求
	* 客户端从键盘读入字符串
	* 客户端拆分字符串为一个分组（多个数据包）
	* 客户端依次发送数据包，并阻塞等待ack，超时重传
	* 服务器收到数据包后发送ack，ack不等待回复
	* 服务器收到所有数据包后，开始计算url encoded字符串，并将其拆分成分组数据包
* **阶段2：客户端请求答案字符串**
	* 客户端发送ask for answer 请求，该请求需求回复，超时重传
	* 服务器端收到ask for answer 请求，开始依次发送答案数据包，并阻塞等待ack，超时重传
	* 客户端收到所有答案数据包后，将其组合成答案字符串显示给用户。发送END OF SESSION数据包到服务器，不等待确认（丢包处理方式在后面描述），直接进入下一轮等待键盘输入
	* 服务器在收到END OF SESSION数据包后，结束当次对话，从timestamp\_to\_rawstrings字典中删除本次对话数据，释放内存。

	
### 可靠性设计：

在本次实验中，我使用随机数方式模拟了一个每次数据发送有20%丢包率的网络环境。因此，对丢包的妥善处理是协议可靠性的重要保证。时间和能力所限，我尽量对丢包的各种情况进行了思考和处理，肯定还有不完善的地方，请老师和助教多多指正，帮助我更全面地认识和解决可靠性设计的问题。

* 处理原则
	* 所有数据包都需要等待接收方返回的确认包（ack），超时重传
	* ack反射数据包的所有信息（除了package type）。数据包收到确认后，比对时间戳、内容等信息，如不匹配则重传
	* 同一分组的数据包依次发送，上一个收到确认后再发送下一个
	* 所有ack不需要确认和重传

* 情况讨论
	* <a>数据包丢失</a>
		
		数据包发出后会等待ack。当数据包丢失时，接收方处于阻塞接收状态，无法返回ack，使得发送方等待超时，重传数据包。由于采取数据包重复覆盖原则，发送重复数据包不会产生负面影响。
	
	* <a>ack丢失</a>

		ack的丢失必定会导致发送方的超时重传。由于数据包采取重复覆盖的原则，即便对方将同一数据包传送了多次，也不会影响结果。
	
	* <a>ask for answer 数据包丢失</a>

		ask for answer数据包是等待确认的，超时重传。
	
	* <a>END OF SESSION 数据包丢失</a>

		这个问题比较棘手，也是花了最多时间考虑和尝试的……因为客户端和服务器需要进行多轮会话，因此如何使得双方都能知道一次会话已经结束非常重要。由于END OF SESSION可能丢失，而如果END OF SESSION采取确认重传机制，就造成一个“拜占庭将军问题”，永远无法达到可靠的一致性：客户端不知道是否可以发送下一次请求，服务器不知道是否需要重传最后一个答案数据包（这里END OF SESSION 同时作为最后一个答案数据包的ack）。
		
		这里的处理方式是：END OF SESSION数据包不等待确认。当客户端发出该数据包后，即结束当前会话，进入下一轮等待键盘输入。获取键盘输入后，将第一个请求数据包发送给服务器，然后等待确认。
		
		服务器此时正在等待END OF SESSION数据包，否则会重传最后一个答案数据包。此答案数据包被客户端接受，但时间戳与客户端期待的时间戳不符，客户端丢弃此数据包并重传请求数据包。
		
		当服务器等待END OF SESSION，却收到一个不同时间戳的请求数据包时，服务器意识到此数据包属于一个新的会话，因此结束上一次对话，释放上一次会话的内存，并发出ack，开始新的会话服务。
		
		另一种特殊情况是，当客户端长时间等待键盘输入未果时，服务器会不断发送最后一个结果数据包，当其重传次数达到限制时，就会停止重传，关闭当前会话，进入下一次会话的等待中。
		
		
## 另附
随报告附服务器和客户端的C++源码以及cmake文件，使用clang编译运行